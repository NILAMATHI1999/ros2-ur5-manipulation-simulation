# UR5 HRI Manipulation â€“ ROS2 Simulation Demo

This project demonstrates a ROS2-based simulation of a UR5 manipulator for Humanâ€“Robot Interaction (HRI).  
It includes a custom ROS2 node that publishes joint trajectories and moves the UR5 robot inside RViz.

---

## ðŸ“Œ Features Implemented

### âœ” 1. UR5 Robot Visualization
- UR5 URDF loaded into RViz  
- Custom RViz configuration (`ur5_hri_simulation_fixed.rviz`)  
- Robot model fully visible with correct TFs  

### âœ” 2. ROS2 Joint-Motion Node
A custom ROS2 Python node:

`src/ur5_joint_motion_node.py`

Implements:
- Joint-state publishing  
- Periodic sinusoidal motion on selected joints  
- Smooth, continuous robot movement  
- No GUI sliders required  

Run using:

```bash
ros2 run hri_manipulation ur5_joint_motion_node
````

---

## ðŸŽ¥ Demo Video

`videos/ur5_joint_motion_demo.mp4`

Shows:

* UR5 robot rendering in RViz
* Joint motion generated by the Python ROS2 node


## ðŸŽ¥ Demo
![UR5 Demo](images/ur5_demo.gif)

---

## ðŸ–¼ Screenshots

Inside `images/`:

* `ur5_demo_screenshot.png` â€“ UR5 visible in RViz
* Additional captures if needed

---

## ðŸ“¦ Project Structure

```
ros2_ur5_sim/
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ur5_joint_motion_node.py
â”‚
â”œâ”€â”€ rviz/
â”‚   â””â”€â”€ ur5_hri_simulation_fixed.rviz
â”‚
â”œâ”€â”€ images/
â”‚   â””â”€â”€ ur5_demo_screenshot.png
â”‚
â””â”€â”€ videos/
    â””â”€â”€ ur5_joint_motion_demo.mp4
```

---

## ðŸš€ How to Run

### 1. Load RViz

```bash
rviz2 -d ~/ros2_ws/ur5_hri_simulation_fixed.rviz
```

### 2. Start Motion Node

```bash
source ~/ros2_ws/install/setup.bash
ros2 run hri_manipulation ur5_joint_motion_node
```

---

## ðŸ“˜ Goal of the Project

This project simulates core HRI/Manipulation concepts:

* Robot motion control
* Joint-space trajectory generation
* Visualization of manipulator kinematics
* ROS2 nodeâ€“based arm actuation

## ðŸ¦¾ HRI Manipulation â€“ Planar 3-DoF Arm 

This part of the repository implements a **HRI manipulation ** using a planar 3-DoF arm model in Python + ROS2.  
It covers the full pipeline from kinematics to interaction:

### Implemented Components

- **Planar Arm Kinematics (`planar_arm.py`)**
  - 3-DoF planar manipulator
  - Forward kinematics: \[(q1, q2, q3) â†’ (x, y, Î±)\]
  - Inverse kinematics: \[(x, y, Î±) â†’ (q1, q2, q3)\]

- **IK Node (`ik_node.py`)**
  - ROS2 node that computes IK for a fixed end-effector target
  - Publishes joint angles on topic: `/joint_angles` (`Float64MultiArray`)

- **Jacobian + Torque Mapping Node (`jacobian_torque_node.py`)**
  - Subscribes to `/joint_angles`
  - Computes the analytical Jacobian of the 3-DoF arm
  - Uses **Ï„ = Jáµ€Â·F** to map a simulated force vector **F** to joint torques
  - Publishes torques on `/joint_torque` (`Float64MultiArray`)

- **Admittance Control Node (`admittance_node.py`)**
  - Subscribes to `/joint_torque`
  - Converts torque magnitude â†’ external force input
  - Simulates 1-DoF **admittance control** using a massâ€“springâ€“damper model:

    \[
    M \ddot{x} + D \dot{x} + K x = F
    \]

  - Integrates position over time and publishes on `/admittance_position`

### How to Run (Task 2 Pipeline)

In three terminals:

```bash
# Terminal 1 â€“ Inverse Kinematics node
ros2 run hri_manipulation ik_node

# Terminal 2 â€“ Jacobian torque node
ros2 run hri_manipulation jacobian_torque_node

# Terminal 3 â€“ Admittance control node
ros2 run hri_manipulation admittance_node
